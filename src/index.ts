import { app, autoUpdater, BrowserWindow, dialog, ipcMain, shell } from "electron";
import { readFile, readFileSync, writeFile, writeFileSync } from "jsonfile";
import { writeFile as exportToPdf } from "original-fs";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const decipher = (salt: string) => {
  const textToChars = (text: string) =>
    text.split("").map((c: string) => c.charCodeAt(0));
  const applySaltToChar = (code: any) =>
    textToChars(salt).reduce((a: number, b: number) => a ^ b, code);
  return (encoded: string) =>
    encoded
      .match(/.{1,2}/g)
      .map((hex: string) => parseInt(hex, 16))
      .map(applySaltToChar)
      .map((charCode) => String.fromCharCode(charCode))
      .join("");
};

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

type comp = {
  date: string;
  summaryGenerated: boolean;
  id: string;
  name: string;
  logo: string;
  mainJudge: string;
  secretaryJudge: string;
  competetors: any[];
  finals: any[];
};

export type summary = {
  id: string;
  name: string;
  compIds: string[];
};

type json = {
  license: string;
  competitions: comp[];
  summaries: summary[];
};

function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
      v = c == "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

let mainWindow: BrowserWindow;

const createWindow = (): void => {
  const server = "https://hazel-n1ghtbox.vercel.app"
  const url = `${server}/update/${process.platform}/${app.getVersion()}`

  autoUpdater.setFeedURL({ url })

  autoUpdater.on('update-downloaded', (event, releaseNotes, releaseName) => {
    const dialogOpts = {
      type: 'info',
      buttons: ['Zaktualizuj', 'Później'],
      title: 'Aktualizacja',
      message: process.platform === 'win32' ? releaseNotes : releaseName,
      detail:
        'Nowa wersja aplikacji. Czy chcesz zaktualizować?'
    }
  
    dialog.showMessageBox(dialogOpts).then((returnValue) => {
      if (returnValue.response === 0) autoUpdater.quitAndInstall()
    })
  })
  try {
    readFileSync("./data.json");
    autoUpdater.checkForUpdates()
  } catch {
    writeFileSync("./data.json", {
      license: "",
      competitions: [],
      summaries: [],
    });
  }
  // let exists =
  // Create the browser window.
  mainWindow = new BrowserWindow({
    icon:'image.ico',
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.setBackgroundColor("#f2f2f2");
  mainWindow.title = "Castingsport";
  // Open the DevTools.
  mainWindow.maximize();
  mainWindow.menuBarVisible = false;

  

// #region Summaries
  ipcMain.handle("getCompetitionsWithFinals", async () => {
    let json: json = await readFile("./data.json");
    return json.competitions.filter((x) => x.finals && x.finals.length > 0);
  });

  ipcMain.handle("getSummaries", async () => {
    let json: json = await readFile("./data.json");
    return json.summaries;
  });

  ipcMain.handle("getSummary", async (_:any, ...args:any[]) => {
    let json: json = await readFile("./data.json");
    return json.summaries.find(x=>x.id === args[0]);
  });

  
  ipcMain.handle("getFinalsById", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    return json.competitions.filter(x => args[0].includes(x.id)).map(x =>{return{scores:x.finals, name:x.name}});
  });

  ipcMain.handle("addSummary", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let newSummary = {
      ...args[0],
      id: uuidv4(),
    };
    if(!json.summaries) json.summaries = []
    json.summaries = [...json.summaries, newSummary];
    await writeFile("./data.json", json);
    return newSummary;
  });

  ipcMain.handle("deleteSummary", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    json.summaries = json.summaries.filter(x => x.id != args[0]);
    await writeFile("./data.json", json);
    return json.summaries;
  });

  ipcMain.handle("generateFinalResults", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let id = args[0];
    let comp = json.competitions.find((x) => x.id == id);
    if (!comp) return false;
    const getScore = (competetor: any, range: [number, number]) => {
      let score = 0;
      for (let i = range[0] - 1; i < range[1]; i++) {
        let element: any = Object.values(competetor.disciplines).find(
          (x: any) => x.number == i + 1
        );
        score +=
          typeof element.score == "string"
            ? parseFloat(element.score)
            : element.score;
        score += element.score2
          ? typeof element.score2 == "string"
            ? parseFloat(element.score2)
            : element.score2
          : 0;
      }
      return Math.round(score * 1000) / 1000;
    };

    let scores = comp.competetors.map((x) => {
      return {
        name: x.name,
        club: x.club,
        category: x.category,
        team: x.team,
        girl: x.girl,
        score3: getScore(x, [3, 5]),
        score5: getScore(x, [1, 5]),
        score7: getScore(x, [1, 7]),
        score9: getScore(x, [1, 9]),
      };
    });

    let groupedByCategory: any = {
      Kadet: [],
      Junior: [],
      Juniorka: [],
      Kobieta: [],
      Senior: [],
    };
    for (let i = 0; i < scores.length; i++) {
      const element = scores[i];
      groupedByCategory[element.category].push(element);
      if (element.category === "Kadet" && element.score3 < element.score5) {
        if (element.girl) groupedByCategory["Juniorka"];
        else groupedByCategory["Junior"];
      }
    }

    scores = [];

    Object.keys(groupedByCategory).forEach((key) => {
      if (key === "Kadet")
        groupedByCategory[key].sort((a: any, b: any) => b.score3 - a.score3);
      else groupedByCategory[key].sort((a: any, b: any) => b.score5 - a.score5);
      scores = [
        ...scores,
        ...(groupedByCategory[key] as any[]).map((x: any, index: number) => {
          return { ...x, place: index + 1 };
        }),
      ];
    });

    comp.summaryGenerated = true;
    comp.finals = scores;

    json.competitions.splice(
      json.competitions.findIndex((x) => x.id == id),
      1,
      comp
    );

    await writeFile("./data.json", json);
    return json.competitions;
  });

//#endregion

// #region Miscellaneous
  ipcMain.handle("openLinkedIn", async () => {
    await shell.openExternal(
      "https://www.linkedin.com/in/dawid-witczak-568591226/"
    );
    return;
  });

  ipcMain.handle(
    "checkLicense",
    async (): Promise<{ valid: boolean; errorMessage: string }> => {
      let json: json = await readFile("./data.json");
      let license = json.license;
      if (!license)
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let myDipher = decipher("Yjxs8W91HjG!NbJ&yhtN");
      let decodedLicense = myDipher(license);
      let splitLicense = decodedLicense.split(":");
      if (splitLicense[0] !== "Castingsport-RS")
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let date = new Date(splitLicense[1]);
      if (date < new Date())
        return { valid: false, errorMessage: "Licencja wygasla" };
      return { valid: true, errorMessage: "" };
    }
  );

  ipcMain.handle(
    "saveLicense",
    async (
      _: any,
      ...args: any[]
    ): Promise<{ valid: boolean; errorMessage: string }> => {
      let json: json = await readFile("./data.json");
      let license = args[0];
      if (!license)
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let myDipher = decipher("Yjxs8W91HjG!NbJ&yhtN");
      let decodedLicense = myDipher(license);
      let splitLicense = decodedLicense.split(":");
      if (splitLicense[0] !== "Castingsport-RS")
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let date = new Date(splitLicense[1]);
      if (date < new Date())
        return { valid: false, errorMessage: "Licencja wygasla" };
      json.license = license;
      await writeFile("./data.json", json);
      return { valid: true, errorMessage: "" };
    }
  );
// #endregion

// #region Competitions

  ipcMain.handle("getCompetitions", async () => {
    let json: json = await readFile("./data.json");
    return json.competitions;
  });

  
  ipcMain.handle("importList", async (_: any, ...args: any[]) => {
    let path = dialog.showOpenDialogSync({
      filters: [{ name: "Plik JSON", extensions: ["json"] }],
      properties: ["openFile"],
    });
    let data = await readFile(path[0]);
    return JSON.stringify(data.data);
  });


  ipcMain.handle("saveCompetiton", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let compIndex = json.competitions.findIndex((x) => x.id == args[0].id);
    let oldComp = json.competitions[compIndex];
    json.competitions[compIndex] = {
      ...oldComp,
      competetors: args[1] ? args[0].competetors.filter((x:any) => x.startingNumber) : args[0].competetors,
    };
    await writeFile("./data.json", json);
    return true;
  });

  ipcMain.handle("getById", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let compIndex = json.competitions.findIndex((x) => x.id == args[0]);
    return json.competitions[compIndex];
  });

  ipcMain.handle("createNewComp", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let generatedId = uuidv4();
    json.competitions.push({
      id: generatedId,
      ...args[0],
      summaryGenerated: false,
      competetors: [],
      finals:[]
    });
    await writeFile("./data.json", json);
    return generatedId;
  });

  ipcMain.handle("deleteComp", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let compIndex = json.competitions.findIndex((x) => x.id == args[0]);

    json.competitions.splice(compIndex, 1);

    await writeFile("./data.json", json);
    return json;
  });

  ipcMain.handle("editComp", async (_: any, ...args: any[]) => {
    let json: json = await readFile("./data.json");
    let compIndex = json.competitions.findIndex((x) => x.id == args[0].id);
    let compToEdit = json.competitions[compIndex];
    compToEdit = {
      ...compToEdit,
      mainJudge: args[0].mainJudge,
      secretaryJudge: args[0].secretaryJudge,
      logo: args[0].logo,
      name: args[0].name,
      date: args[0].date,
    };

    json.competitions.splice(compIndex, 1, compToEdit);

    await writeFile("./data.json", json);
    return json.competitions;
  });
// #endregion

// #region Prints
  ipcMain.handle("printResults", async (_: any, ...args: any[]) => {
    mainWindow.webContents.print({}, (success, fail) => {
      if (fail === "Print job canceled") mainWindow.webContents.send("success");
      if (success) mainWindow.webContents.send("success");
    });
  });
// #endregion

// #region Exports
  ipcMain.handle("exportToPdf", async (_: any, ...args: any[]) => {
    let path = dialog.showOpenDialogSync({
      properties: ["openDirectory"],
    });
    if (!path || path.length <= 0) mainWindow.webContents.send("success");
    mainWindow.webContents.printToPDF({}).then((data) => {
      exportToPdf(`${path[0]}/${args[0]}`, data, () => {
        mainWindow.webContents.send("success");
      });
    });
  });

  ipcMain.handle("exportList", async (_: any, ...args: any[]) => {
    let competetors = JSON.parse(args[0]);
    let data = competetors.map((comp: any) => {
      return {
        key: comp.key,
        girl: comp.girl,
        name: comp.name,
        team: comp.team,
        category: comp.category,
        club: comp.club,
      };
    });
    let path = dialog.showSaveDialogSync({
      filters: [{ name: "Plik JSON", extensions: ["json"] }],
    });
    await writeFile(`${path}`, { data });
    return true;
  });
// #endregion

  // #region Dev
  ipcMain.handle("DEV_getData", async (_: any) => {
    let json: json = await readFile("./data.json");

    let path = dialog.showSaveDialogSync({
      defaultPath:'data.json',
      filters: [{ name: "Plik JSON", extensions: ["json"], }],
    });
    await writeFile(`${path}`, json);
    return true;
  });

  ipcMain.handle("DEV_importData", async (_: any) => {
    let path = dialog.showOpenDialogSync({
      defaultPath:'data.json',
      properties:['openFile'],
      filters: [{ name: "", extensions: ["json"], }],
    });
    let json: json = await readFile(`${path[0]}`);
    await writeFile("./data.json", json);
    return true;
  });

  ipcMain.handle("DEV_getLicense", async (_: any) => {
    let json: json = await readFile("./data.json");
    let license = json.license;
    if (!license)
      return {
        valid: false,
        errorMessage: "Nie znaleziono prawidlowej licencji",
      };
    let myDipher = decipher("Yjxs8W91HjG!NbJ&yhtN");
    return myDipher(license);
  });
// #endregion
  
  // autoUpdater.checkForUpdatesAndNotify() 
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
