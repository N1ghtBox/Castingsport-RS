import {
  app,
  autoUpdater,
  BrowserWindow,
  dialog,
  ipcMain,
  shell,
} from "electron";
import { readFile, readFileSync, writeFile, writeFileSync } from "jsonfile";
import { writeFile as exportToPdf } from "original-fs";
import isDev from "electron-is-dev";
import { Categories, Teams } from "./enums";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export type team = {
  name:string,
  team:any[],
  category:string,
  score:number,
  place:number,
}

const filePath = isDev ? "./data.json" : "./../data.json";

const decipher = (salt: string) => {
  const textToChars = (text: string) =>
    text.split("").map((c: string) => c.charCodeAt(0));
  const applySaltToChar = (code: any) =>
    textToChars(salt).reduce((a: number, b: number) => a ^ b, code);
  return (encoded: string) =>
    encoded
      .match(/.{1,2}/g)
      .map((hex: string) => parseInt(hex, 16))
      .map(applySaltToChar)
      .map((charCode) => String.fromCharCode(charCode))
      .join("");
};

const generateIndividualScores = async (comp:comp) => {
  const getScore = (competetor: any, range: [number, number]) => {
    let score = 0;
    for (let i = range[0] - 1; i < range[1]; i++) {
      let element: any = Object.values(competetor.disciplines).find(
        (x: any) => x.number == i + 1
      );
      score +=
        typeof element.score == "string"
          ? parseFloat(element.score) * ([5,7,9].includes(i+1) ? 1.5 : 1)
          : element.score * ([5,7,9].includes(i+1) ? 1.5 : 1);
      score += element.score2
        ? typeof element.score2 == "string"
          ? parseFloat(element.score2)
          : element.score2
        : 0;
    }
    return Math.round(score * 1000) / 1000;
  };

  let IndividualScores = comp.competetors.map((x) => {
    return {
      name: x.name,
      club: x.club,
      category: x.category,
      team: x.team,
      girl: x.girl,
      score3: getScore(x, [3, 5]),
      score5: getScore(x, [1, 5]),
      score7: getScore(x, [1, 7]),
      score9: getScore(x, [1, 9]),
      shouldInclude: x.disciplines[0].takesPart && x.category == Categories.Kadet
    };
  });

  let groupedByCategory: any = {
    Kadet: [],
    Junior: [],
    Juniorka: [],
    Kobieta: [],
    Senior: [],
  };
  for (let i = 0; i < IndividualScores.length; i++) {
    const element = IndividualScores[i];
    groupedByCategory[element.category].push(element);
    if (element.category === "Kadet" && (element.score3 < element.score5 || element.shouldInclude) ) {
      if (element.girl) groupedByCategory["Juniorka"].push({...element, category:"Juniorka"});
      else groupedByCategory["Junior"].push({...element, category:"Junior"});
    }
  }

  IndividualScores = [];

  Object.keys(groupedByCategory).forEach((key) => {
    if (key === "Kadet")
      groupedByCategory[key].sort((a: any, b: any) => b.score3 - a.score3);
    else groupedByCategory[key].sort((a: any, b: any) => b.score5 - a.score5);
    IndividualScores = [
      ...IndividualScores,
      ...(groupedByCategory[key] as any[]).map((x: any, index: number) => {
        return { ...x, place: index + 1 };
      }),
    ];
  });

  return IndividualScores
} 

const generateTeamsScores = async (comp:comp):Promise<any[]> => {
  const getScore = (competetor: any, range: [number, number]) => {
    let score = 0;
    for (let i = range[0] - 1; i < range[1]; i++) {
      let element: any = Object.values(competetor.disciplines).find(
        (x: any) => x.number == i + 1
      );
      score +=
        typeof element.score == "string"
          ? parseFloat(element.score) * ([5,7,9].includes(i+1) ? 1.5 : 1)
          : element.score * ([5,7,9].includes(i+1) ? 1.5 : 1);
      score += element.score2
        ? typeof element.score2 == "string"
          ? parseFloat(element.score2)
          : element.score2
        : 0;
    }
    return Math.round(score * 1000) / 1000;
  };

  let IndividualScores = comp.competetors.map((x) => {
    return {
      name: x.name,
      club: x.club,
      category: x.category,
      team: x.team,
      girl: x.girl,
      score3: getScore(x, [3, 5]),
      score5: getScore(x, [1, 5]),
      score7: getScore(x, [1, 7]),
      score9: getScore(x, [1, 9]),
      shouldInclude: x.disciplines[0].takesPart && x.category == Categories.Kadet
    };
  });
  
  let groupedByTeam = {
    Teen: [] as team[],
    Man: [] as team[],
    Woman: [] as team[],
  }
  
  const mapToTeamCategory = (team:string): keyof typeof groupedByTeam | undefined => {
    if(team == Teams.Młodzieżowa) return 'Teen'
    if(team == Teams.Kobiet) return 'Woman'
    if(team == Teams.Seniorów) return 'Man'
    return undefined
  }

  IndividualScores.forEach(competetor => {
    let category = mapToTeamCategory(competetor.team)
    if(!category) return 
    const teamCategoryArray = groupedByTeam[category]
    if(teamCategoryArray.find(x => x.name == competetor.club)){
      let indexOfExistingTeam = teamCategoryArray.findIndex(x => x.name == competetor.club)
      teamCategoryArray[indexOfExistingTeam].score += parseFloat(competetor.score5.toFixed(3))
      teamCategoryArray[indexOfExistingTeam].team.push(competetor)
    }else{
      teamCategoryArray.push({
        name:competetor.club,
        score:parseFloat(competetor.score5.toFixed(3)),
        place:0,
        category:competetor.team,
        team:[{...competetor}]
      })
    }
  })

  Object.keys(groupedByTeam).forEach((category: keyof typeof groupedByTeam) => {
    groupedByTeam[category] = groupedByTeam[category].sort((a,b) => b.score - a.score).map((team, i) => {
      return {...team, place: i + 1}
    })
  })

  return [...groupedByTeam.Man, ...groupedByTeam.Teen, ...groupedByTeam.Woman]
} 

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

type comp = {
  date: string;
  summaryGenerated: boolean;
  id: string;
  finalId:string;
  name: string;
  logo: string;
  mainJudge: string;
  secretaryJudge: string;
  competetors: any[];
};

export type summary = {
  id: string;
  name: string;
  compIds: string[];
};

type json = {
  license: string;
  competitions: comp[];
  finals: {id:string, name:string, scores:{teams:any[], individual:any[]}}[];
  summaries: summary[];
};

function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
      v = c == "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

let mainWindow: BrowserWindow;

const createWindow = (): void => {
  const server = "https://hazel-n1ghtbox.vercel.app";
  const url = `${server}/update/${process.platform}/${app.getVersion()}`;

  autoUpdater.setFeedURL({ url });

  autoUpdater.on("update-downloaded", (event, releaseNotes, releaseName) => {
    const dialogOpts = {
      type: "info",
      buttons: ["Zaktualizuj", "Później"],
      title: "Aktualizacja",
      message: process.platform === "win32" ? releaseNotes : releaseName,
      detail: "Nowa wersja aplikacji. Czy chcesz zaktualizować?",
    };

    dialog.showMessageBox(dialogOpts).then((returnValue) => {
      if (returnValue.response === 0) autoUpdater.quitAndInstall();
    });
  });
  try {
    readFileSync(filePath);
    if (!isDev) autoUpdater.checkForUpdates();
  } catch (ex) {
    writeFileSync(filePath, {
      license: "",
      competitions: [],
      summaries: [],
      finals:[]
    });
  }
  // let exists =
  // Create the browser window.
  mainWindow = new BrowserWindow({
    icon: "image.ico",
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.setBackgroundColor("#f2f2f2");
  mainWindow.title = "Castingsport";
  // Open the DevTools.
  mainWindow.maximize();
  mainWindow.menuBarVisible = false;

  // #region Summaries
  ipcMain.handle("getCompetitionsWithFinals", async () => {
    let json: json = await readFile(filePath);
    return json.competitions.filter(x => x.finalId);
  });

  ipcMain.handle("getSummaries", async () => {
    let json: json = await readFile(filePath);
    return json.summaries;
  });

  ipcMain.handle("getSummary", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    return json.summaries.find((x) => x.id === args[0]);
  });

  ipcMain.handle("getFinalsById", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    return args[0].map((id:string) => {
      let comp = json.finals.find(x => x.id === id)
      return { scores: comp.scores, name: comp.name };
    });
  });

  ipcMain.handle("addSummary", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let newSummary = {
      ...args[0],
      id: uuidv4(),
    };
    if (!json.summaries) json.summaries = [];
    json.summaries = [...json.summaries, newSummary];
    await writeFile(filePath, json);
    return newSummary;
  });

  ipcMain.handle("deleteSummary", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    json.summaries = json.summaries.filter((x) => x.id != args[0]);
    await writeFile(filePath, json);
    return json.summaries;
  });

  ipcMain.handle("generateFinalResults", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let id = args[0];
    let comp = json.competitions.find((x) => x.id == id);
    if (!comp) return false;

    let [IndividualScores, TeamsScores] = await Promise.all([generateIndividualScores(comp), generateTeamsScores(comp)])
    if(comp.finalId) json.finals.splice(json.finals.findIndex(x => x.id == comp.finalId), 1, {id:comp.finalId, scores:{individual: IndividualScores, teams:TeamsScores}, name: comp.name})
    else {
      let finalId = uuidv4()
      json.finals.push({id:finalId, scores:{individual: IndividualScores, teams:TeamsScores}, name: comp.name})
      comp.finalId = finalId;
    };
    comp.summaryGenerated = true;
    await writeFile(filePath, json);

    return json.competitions;
  });

  //#endregion

  // #region Miscellaneous
  ipcMain.handle("openLinkedIn", async () => {
    await shell.openExternal(
      "https://www.linkedin.com/in/dawid-witczak-568591226/"
    );
    return;
  });

  ipcMain.handle(
    "checkLicense",
    async (): Promise<{ valid: boolean; errorMessage: string }> => {
      let json: json = await readFile(filePath);
      let license = json.license;
      if (!license)
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let myDipher = decipher("Yjxs8W91HjG!NbJ&yhtN");
      let decodedLicense = myDipher(license);
      let splitLicense = decodedLicense.split(":");
      if (splitLicense[0] !== "Castingsport-RS")
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let date = new Date(splitLicense[1]);
      if (date < new Date())
        return { valid: false, errorMessage: "Licencja wygasla" };
      return { valid: true, errorMessage: "" };
    }
  );

  ipcMain.handle(
    "saveLicense",
    async (
      _: any,
      ...args: any[]
    ): Promise<{ valid: boolean; errorMessage: string }> => {
      let json: json = await readFile(filePath);
      let license = args[0];
      if (!license)
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let myDipher = decipher("Yjxs8W91HjG!NbJ&yhtN");
      let decodedLicense = myDipher(license);
      let splitLicense = decodedLicense.split(":");
      if (splitLicense[0] !== "Castingsport-RS")
        return {
          valid: false,
          errorMessage: "Nie znaleziono prawidlowej licencji",
        };
      let date = new Date(splitLicense[1]);
      if (date < new Date())
        return { valid: false, errorMessage: "Licencja wygasla" };
      json.license = license;
      await writeFile(filePath, json);
      return { valid: true, errorMessage: "" };
    }
  );
  // #endregion

  // #region Competitions

  ipcMain.handle("getCompetitions", async () => {
    let json: json = await readFile(filePath);
    return json.competitions;
  });

  ipcMain.handle("importList", async (_: any, ...args: any[]) => {
    let path = dialog.showOpenDialogSync({
      filters: [{ name: "Plik JSON", extensions: ["json"] }],
      properties: ["openFile"],
    });
    let data = await readFile(path[0]);
    return JSON.stringify(data.data);
  });

  ipcMain.handle("saveCompetiton", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let compIndex = json.competitions.findIndex((x) => x.id == args[0].id);
    let oldComp = json.competitions[compIndex];
    json.competitions[compIndex] = {
      ...oldComp,
      competetors: args[1]
        ? args[0].competetors.filter((x: any) => x.startingNumber)
        : args[0].competetors,
    };
    await writeFile(filePath, json);
    return true;
  });

  ipcMain.handle("getById", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let compIndex = json.competitions.findIndex((x) => x.id == args[0]);
    return json.competitions[compIndex];
  });

  ipcMain.handle("createNewComp", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let generatedId = uuidv4();
    json.competitions.push({
      id: generatedId,
      ...args[0],
      summaryGenerated: false,
      competetors: [],
      finals: [],
    });
    await writeFile(filePath, json);
    return generatedId;
  });

  ipcMain.handle("deleteComp", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let compIndex = json.competitions.findIndex((x) => x.id == args[0]);

    json.competitions.splice(compIndex, 1);

    await writeFile(filePath, json);
    return json;
  });

  ipcMain.handle("editComp", async (_: any, ...args: any[]) => {
    let json: json = await readFile(filePath);
    let compIndex = json.competitions.findIndex((x) => x.id == args[0].id);
    let compToEdit = json.competitions[compIndex];
    compToEdit = {
      ...compToEdit,
      mainJudge: args[0].mainJudge,
      secretaryJudge: args[0].secretaryJudge,
      logo: args[0].logo,
      name: args[0].name,
      date: args[0].date,
    };

    json.competitions.splice(compIndex, 1, compToEdit);

    await writeFile(filePath, json);
    return json.competitions;
  });
  // #endregion

  // #region Prints
  ipcMain.handle("printResults", async (_: any, ...args: any[]) => {
    mainWindow.webContents.print({}, (success, fail) => {
      if (fail === "Print job canceled") mainWindow.webContents.send("success");
      if (success) mainWindow.webContents.send("success");
    });
  });
  // #endregion

  // #region Exports
  ipcMain.handle("exportToPdf", async (_: any, ...args: any[]) => {
    let path = dialog.showOpenDialogSync({
      properties: ["openDirectory"],
    });
    if (!path || path.length <= 0) mainWindow.webContents.send("success");
    mainWindow.webContents.printToPDF({}).then((data) => {
      exportToPdf(`${path[0]}/${args[0]}`, data, () => {
        mainWindow.webContents.send("success");
      });
    });
  });

  ipcMain.handle("exportList", async (_: any, ...args: any[]) => {
    let competetors = JSON.parse(args[0]);
    let data = competetors.map((comp: any) => {
      return {
        key: comp.key,
        girl: comp.girl,
        name: comp.name,
        team: comp.team,
        category: comp.category,
        club: comp.club,
      };
    });
    let path = dialog.showSaveDialogSync({
      filters: [{ name: "Plik JSON", extensions: ["json"] }],
    });
    await writeFile(`${path}`, { data });
    return true;
  });
  // #endregion

  // #region Dev
  ipcMain.handle("DEV_getData", async (_: any) => {
    let json: json = await readFile(filePath);

    let path = dialog.showSaveDialogSync({
      defaultPath: "data.json",
      filters: [{ name: "Plik JSON", extensions: ["json"] }],
    });
    await writeFile(`${path}`, json);
    return true;
  });

  ipcMain.handle("DEV_importData", async (_: any) => {
    let path = dialog.showOpenDialogSync({
      defaultPath: "data.json",
      properties: ["openFile"],
      filters: [{ name: "", extensions: ["json"] }],
    });
    let json: json = await readFile(`${path[0]}`);
    await writeFile(filePath, json);
    return true;
  });

  ipcMain.handle("DEV_getLicense", async (_: any) => {
    let json: json = await readFile(filePath);
    let license = json.license;
    if (!license)
      return {
        valid: false,
        errorMessage: "Nie znaleziono prawidlowej licencji",
      };
    let myDipher = decipher("Yjxs8W91HjG!NbJ&yhtN");
    return myDipher(license);
  });
  // #endregion

  // autoUpdater.checkForUpdatesAndNotify()
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
