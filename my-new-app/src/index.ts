import { app, BrowserWindow, dialog, ipcMain } from 'electron';
import { readFile, readFileSync, writeFile, writeFileSync } from 'jsonfile';
import {writeFile as exportToPdf} from 'original-fs'
import AES from 'crypto-js/aes'
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

type comp = {
  date:string,
  id:string,
  name:string,
  logo:string,
  competetors:any[]
}

type json = {
  license:string
  competitions:comp[]
}

function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
  .replace(/[xy]/g, function (c) {
      const r = Math.random() * 16 | 0, 
          v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
  });
}

let mainWindow: BrowserWindow;

const createWindow = (): void => {
  try{
    readFileSync('./data.json')
  }catch{
    writeFileSync('./data.json',{license:"",competitions:[]})
  }
  // let exists = 
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration:true,
      contextIsolation:false
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  mainWindow.setBackgroundColor('#f2f2f2')
  mainWindow.title = "Castingsport"
  // Open the DevTools.
  mainWindow.maximize();
  mainWindow.menuBarVisible = false;

  ipcMain.handle('getCompetitions',async () => {
    let json:json = await readFile('./data.json')
    return json.competitions
  })

  ipcMain.handle('checkLicense',async ():Promise<{ valid: boolean; errorMessage:string}> => {
    let json:json = await readFile('./data.json')
    let license = json.license
    if(!license) return {valid:false, errorMessage:'Nie znaleziono prawidlowej licencji'}
    let decodedLicense = AES.decrypt(license,'Yjxs8W91HjG!NbJ&yhtN').toString()
    let splitLicense = decodedLicense.split(':')
    if(splitLicense[0] !== 'Castingsport-RS') return {valid:false, errorMessage:'Nie znaleziono prawidlowej licencji'} 
    let date = new Date(splitLicense[1])
    if(date < new Date()) return {valid:false, errorMessage:'Licencja wygasla'} 
    return {valid:true, errorMessage:''}
  })

  ipcMain.handle('saveLicense',async (_:any, ...args:any[]):Promise<{ valid: boolean; errorMessage:string}> => {
    let json:json = await readFile('./data.json')
    let license = args[0]
    if(!license) return {valid:false, errorMessage:'Nie znaleziono prawidlowej licencji'}
    let decodedLicense = AES.decrypt(license,'Yjxs8W91HjG!NbJ&yhtN').toString()
    let splitLicense = decodedLicense.split(':')
    if(splitLicense[0] !== 'Castingsport-RS') return {valid:false, errorMessage:'Nie znaleziono prawidlowej licencji'} 
    let date = new Date(splitLicense[1])
    if(date < new Date()) return {valid:false, errorMessage:'Licencja wygasla'} 
    json.license = license
    await writeFile('./data.json',json)
    return {valid:true, errorMessage:''}
  })

  ipcMain.handle('saveCompetiton', async (_:any, ...args:any[]) => {
    let json:json = await readFile('./data.json')
    let compIndex = json.competitions.findIndex(x => x.id == args[0].id)
    let oldComp = json.competitions[compIndex]
    json.competitions[compIndex] = {...oldComp, competetors:args[0].competetors}
    await writeFile('./data.json',json)
    return true
  })

  ipcMain.handle('getById', async (_:any, ...args:any[]) => {
    let json:json = await readFile('./data.json')
    let compIndex = json.competitions.findIndex(x => x.id == args[0])
    return json.competitions[compIndex]
  })

  ipcMain.handle('createNewComp', async (_:any, ...args:any[]) => {
    let json:json = await readFile('./data.json')
    let generatedId = uuidv4()
    json.competitions.push({
      id:generatedId,
      competetors:[],
      ...args[0]
    })
    await writeFile('./data.json',json)
    return generatedId
  })

  ipcMain.handle('printResults', async (_:any, ...args:any[]) => {
    mainWindow.webContents.print({},(success, fail) => {
      if(fail === 'Print job canceled') mainWindow.webContents.send('success')
      if(success) mainWindow.webContents.send('success')
    })
  })

  ipcMain.handle('exportToPdf', async (_:any, ...args:any[]) => {
    let path = dialog.showOpenDialogSync({
      properties: [
        'openDirectory']
    })
    if(!path || path.length <= 0) mainWindow.webContents.send('success')
    mainWindow.webContents.printToPDF({}).then(data=> {
      exportToPdf(`${path[0]}/${args[0]}`,data, () => {
        mainWindow.webContents.send('success')
      })
    })
  })

};


// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);



// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
